<!DOCTYPE html>
<html>
<head>
<title>mysql04</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>课程回顾</h2>
<ol>
<li>is null 和 is not null</li>
<li>别名</li>
<li>distinct </li>
<li>&gt;  &lt;  &gt;=  &lt;=  =  !=  &lt;&gt;</li>
<li>and  or</li>
<li>in </li>
<li>between x and y</li>
<li>like   _  %</li>
<li>排序  order by 字段名 asc/desc ，字段</li>
<li>limit 跳过数量,每页数量</li>
<li>数值计算  + - * / %  mod(7,3)</li>
<li>日期</li>
<li>now()</li>
<li>curdate()</li>
<li>curtime()</li>
<li>date(now())</li>
<li>time(now())</li>
<li>extract(year from now()) month day hour minute second</li>
<li>date_format(now(),'格式')
 Y y m c d H h i s</li>
<li>str<em>to</em>date(非标准格式的时间，格式)</li>
<li>ifnull(x,y)</li>
<li>聚合函数</li>
<li>sum()</li>
<li>avg()</li>
<li>max()</li>
<li>min()</li>
<li>count(*)</li>
<li>字符串</li>
<li>concat</li>
<li>charlength</li>
<li>instr   locate</li>
<li>insert</li>
<li>upper  lower</li>
<li>left    right</li>
<li>trim</li>
<li>substring</li>
<li>repeat</li>
<li>replace</li>
<li>reverse</li>
</ol>
<h3>练习</h3>
<ol>
<li>
案例：查询没有上级领导的员工的编号，姓名，工资
select empno,ename,sal from emp
where mgr is null;
</li>
<li>
案例：查询emp表中没有奖金的员工的姓名，职位，工资，以及奖金
select ename,job,sal,comm from emp
where comm is null;
</li>
<li>
案例：查询emp表中含有奖金的员工的编号，姓名，职位，以及奖金
select ename,job,sal,comm from emp
where comm is not null;
</li>
<li>
案例：查询含有上级领导的员工的姓名，工资以及上级领导的编号
select ename,sal,mgr from emp
where mgr is not null;
</li>
<li>
案例：查询emp表中名字以‘S’开头的所有员工的姓名
select ename from emp
where ename like 's%';
</li>
<li>
案例：查询emp表中名字的最后一个字符是'S'的员工的姓名
select ename from emp
where ename like '%s';
</li>
<li>
案例：查询倒数的第2个字符是‘E’的员工的姓名
select ename from emp
where ename like '%e_';
</li>
<li>
案例：查询emp表中员工的倒数第3个字符是‘N’的员工姓名
select ename from emp
where ename like '%n__';
</li>
<li>
案例：查询emp表中员工的名字中包含‘A’的员工的姓名	
select ename from emp
where ename like '%a%';
</li>
<li>
案例：查询emp表中名字不是以'K'开头的员工的所有信息
select ename from emp
where ename not like 'k%';
</li>
<li>
案例：查询emp表中名字中不包含‘A’的所有员工的信息
select ename from emp
where ename not like '%a%';
</li>
<li>
案例：做文员的员工人数（job= CLERK 的）
select count(*) from emp 
where job='clerk';
</li>
<li>
案例：销售人员 job: SALESMAN 的最高薪水
select max(sal) from emp
where job='salesman'
</li>
<li>
案例：最早和最晚入职时间
select min(hiredate),max(hiredate) from emp
</li>
<li>
案例：查询类别 163的商品总库存量
select sum(num) from t<em>item 
where category</em>id=163;
</li>
<li>
案例：查询 类别 163 的商品
select * from t<em>item 
where category</em>id=163;
</li>
<li>
案例：查询商品价格不大于100的商品名称列表
select title from t_item 
where price&lt;=100;
</li>
<li>
案例：查询品牌是联想,且价格在40000以上的商品名称和价格
select title,price from t_item
where title like '%联想%' 
and price&gt;40000;
</li>
<li>
案例：查询品牌是三木,或价格在50以下的商品名称和价格
select title,price from t_item
where title like '%三木%' or price&lt;50;
</li>
<li>
<p>案例：查询品牌是三木、广博、齐心的商品名称和价格
select title,price from t_item
where title like '%三木%'
or title like '%广博%'
or title like '%齐心%'</p>
</li>
<li>
<p>案例：查询品牌不是联想、戴尔的商品名称和价格
select title,price from t<em>item
where title not like '%联想%'
and title not like '%戴尔%';
22.案例：查找品牌是联想且价格大于10000的电脑名称
select title from t</em>item
where title like '%联想%'
and price&gt;10000 and title like '%电脑%';</p>
</li>
<li>
案例：查询联想或戴尔的电脑名称列表
select title from t_item
where title like '%联想%'
or title like '%戴尔%'
</li>
<li>
案例：查询联想、戴尔、三木的商品名称列表
select title from t_item
where title like '%联想%'
or title like '%戴尔%'
or title like '%三木%'
</li>
<li>
案例：查询不是戴尔的电脑名称列表
select title from t_item
where title not like '%戴尔%'
</li>
<li>
案例：查询所有是记事本的名称和价格
select title,price from t_item
where title like '%记事本%';
</li>
<li>
<p>案例：查询品牌是末尾字符是'力'的商品的名称和价格
select title,price from t<em>item
where title like '%力';
29.案例：查询卖点含有'赠'产品名称
select title from t</em>item
where sell_point like '%赠%';
30.案例：查询emp表中员工的编号，姓名，职位，工资，并且工资在1000~2000之间。
select empno,ename,job,sal from emp
where sal between 1000 and 2000;
31.案例：查询emp表中员工在10号部门，并且含有上级领导的员工的姓名，职位，上级领导编号以及所属部门的编号
select ename,job,mgr,deptno from emp
where deptno=10 and mgr is not null;
32.案例：查询emp表中名字中包含'E'，并且职位不是MANAGER的员工的编号，姓名，职位，以及工资
select empno,ename,job,sal from emp
where ename like '%e%' 
and job!='manager';</p>
<p>33.案例：查询emp表中10号部门或者20号部门中员工的编号，姓名，所属部门的编号
select empno,ename,deptno from emp
where deptno=10 or deptno=20;
34.案例：查询emp表中没有奖金或者名字的倒数第2个字母不是T的员工的编号，姓名，职位以及奖金
select empno,ename,job,comm from emp
where comm is null 
or ename not like '%t_';
35.案例：查询工资高于3000或者部门编号是30的员工的姓名，职位，工资，入职时间以及所属部门的编号	
select ename,job,sal,hiredate,deptno from emp
where sal&gt;3000 or deptno=30;
36.案例：查询不是30号部门的员工的所有信息
select * from emp where deptno!=30;
37.案例：查询奖金不为空的员工的所有信息
select * from emp where comm is not null;
38.案例：查询emp表中所有员工的编号，姓名，职位，根据员工的编号进行降序排列
select empno,ename,job from emp
order by empno desc;
39.案例：查询emp表中部门编号是10号或者30号中，所有员工姓名，职务，工资，根据工资进行升序排列
select ename,job,sal,deptno from emp
where deptno=10 or deptno=30
order by sal;
40.案例：查询emp表中所有的数据，然后根据部门的编号进行升序排列，如果部门编号一致，根据员工的编号进行降序排列
select * from emp order by deptno, empno desc;
41.案例：查询emp表中工资高于1000或者没有上级领导的员工的编号，姓名，工资，所属部门的编号，以及上级领导的编号，根据部门编号进行降序排列，如果部门编号一致根据工资进行升序排列。
select empno,ename,sal,deptno,mgr from emp
where sal&gt;1000 or mgr is null
order by deptno desc, sal;</p>
<p>42.案例：查询emp表中名字中不包含S的员工的编号，姓名，工资，奖金，根据工资进行升序排列，如果工资一致，根据编号进行降序排列
select empno,ename,sal,comm from emp
where ename not like '%s%'
order by sal,empno desc;
43.案例：统计emp表中员工的总数量
select count(<em>) from emp;
44.案例：统计emp表中获得奖金的员工的数量
select count(</em>) from emp
where comm is not null and comm&gt;0;
45.案例：求出emp表中所有的工资累加之和
select sum(sal) from emp;
46.案例：求出emp表中所有的奖金累加之和
select sum(comm) from emp;
47.案例：求出emp表中员工的平均工资
select avg(sal) from emp;
48.案例：求出emp表中员工的平均奖金
select avg(comm) from emp;
49.案例：求出emp表中员工的最高工资
select max(sal) from emp;
50.案例：求出emp表中员工编号的最大值
select max(empno) from emp;
51.案例：查询emp表中员工的最低工资。
select min(sal) from emp;
52.案例：查询emp表中员工的人数，工资的总和，平均工资，奖金的最大值，奖金的最小值,并且对返回的列起别名。
select count(*) 人数,sum(sal) 工资总和,avg(sal) 平均工资, max(comm) 奖金最大值, min(comm) 奖金最小值 from emp;
53.案例：查询emp表中每个部门的编号，人数，工资总和，最后根据人数进行升序排列，如果人数一致，根据工资总和降序排列。
54.案例：查询工资在1000~3000之间的员工信息，每个部门的编号，平均工资，最低工资，最高工资，根据平均工资进行升序排列。
55.案例：查询含有上级领导的员工，每个职业的人数，工资的总和，平均工资，最低工资，最后根据人数进行降序排列，如果人数一致，根据平均工资进行升序排列
56.案例：查询工资在1000~3000之间每一个员工的编号，姓名，职位，工资
select empno,ename,job,sal from emp
where sal between 1000 and 3000;
57.案例：查询emp表中奖金在500~2000之间所有员工的编号，姓名，工资以及奖金
select empno,ename,comm,sal from emp
where comm between 500 and 2000;
58.案例：查询员工的编号是7369，7521，	
select * from emp
where empno in (7369,7521);
59.案例：查询emp表中，职位是ANALYST，
select * from emp
where job='analyst';
60.案例：查询emp表中职位不是ANALYST,
select * from emp
where job!='analyst';</p>
</li>
</ol>
<h3>数学相关函数</h3>
<ul>
<li>
<p>floor(num) 向下取整</p>
<pre><code>select floor(3.84); 值为3
</code></pre>

</li>
<li>
<p>round(num) 四舍五入</p>
<pre><code>select round(23.8); 值为24
</code></pre>

</li>
<li>
<p>round(num,m) 四舍五入  m代表小数位数</p>
<pre><code>select round(23.869,2); 值为23.87
</code></pre>

</li>
<li>
<p>truncate(num,m) 和上面一样（非四舍五入）</p>
<pre><code>select truncate(23.869,2); 值为23.86
</code></pre>

</li>
<li>
<p>rand() 随机数 获取0-1的随机数</p>
<pre><code>    select rand();
</code></pre>

</li>
<li>获取 0-5的随机数</li>
<li>
<p>获取 3-8的随机数</p>
<pre><code>select floor(rand()*6)+3;
</code></pre>

</li>
<li>
获取 8-10的随机数  0-2  <em>3 +8
	select floor(rand()</em>3)+8;
</li>
</ul>
<h3>分组查询</h3>
<ul>
<li>分组查询通常和聚合函数结合使用</li>
<li>一般情况下 每个部门(职位、分类) 就以部门(职位、分类)作为分组的条件</li>
<li>
<p>可以有多个分组条件</p>
</li>
<li>
<p>查询每个部门的最高工资</p>
<pre><code>select deptno,max(sal) from emp group by deptno;
</code></pre>

</li>
<li>
<p>查询每个职位的平均工资</p>
<pre><code>select job,avg(sal) from emp 
group by job;
</code></pre>

</li>
<li>
<p>查询每个部门下每个主管的手下人数</p>
<pre><code>select deptno,mgr,count(*) from emp
group by deptno,mgr;
</code></pre>

</li>
<li>
<p>group by 存在的位置
select * from emp 
where ......
group by ...
order by ...
limit ...</p>
</li>
<li>
<p>练习：把昨天作业超纲的三道题做出来  做10分钟休息10分钟</p>
</li>
<li>
<p>案例：查询emp表中每个部门的编号，人数，工资总和，最后根据人数进行升序排列，如果人数一致，根据工资总和降序排列。
select deptno,count(<em>),sum(sal) from emp
group by deptno
order by count(</em>),sum(sal) desc;</p>
</li>
<li>
<p>案例：查询工资在1000~3000之间的员工信息，每个部门的编号，平均工资，最低工资，最高工资，根据平均工资进行升序排列。</p>
<p>select deptno,avg(sal),min(sal),max(sal) from emp 
where sal between 1000 and 3000
group by deptno
order by avg(sal);</p>
</li>
<li>
<p>案例：查询含有上级领导的员工，每个职业的人数，工资的总和，平均工资，最低工资，最后根据人数进行降序排列，如果人数一致，根据平均工资进行升序排列
select job,count(*) c,sum(sal),avg(sal) a,min(sal) from emp
where mgr is not null
group by job
order by c desc,a;</p>
</li>
</ul>
<h3></h3>
<ol>
<li>查询每个部门的平均工资，要求平均工资大于2000。</li>
<li>
<p>以下为错误语法： where后面不能写聚合函数</p>
<pre><code>select deptno,avg(sal) a from emp
where a&gt;2000
group by deptno;
</code></pre>

</li>
<li>使用having 解决聚合函数的条件过滤问题，having写在group by 后面</li>
<li>
<p>where后面写普通字段的过滤条件，having后面写聚合函数的过滤条件</p>
<pre><code>select deptno,avg(sal) a from emp
group by deptno
having a&gt;2000;      
</code></pre>

</li>
<li>
查询每个分类商品的库存总量，高于199999的库存总量
select category<em>id,sum(num) s from t</em>item
group by category_id
having s&gt;199999;
</li>
<li>
查询每个分类商品所对应的平均单价，要求平均单价低于100
select category<em>id,avg(price) a from t</em>item
group by category_id
having a&lt;100;
</li>
<li>
<p>查询分类id为238和917两个分类的平均单价
select category<em>id,avg(price) from t</em>item
where category<em>id in(238,917)
group by category</em>id;</p>
</li>
<li>
<p>查询emp表中每个部门的平均工资高于2000的部门编号，部门人数，平均工资，最后根据平均工资降序排序
select deptno,count(*),avg(sal) a from emp
group by deptno
having a&gt;2000 
order by a desc;</p>
</li>
<li>
查询emp表中工资在1000-3000之间的员工，每个部门的编号，工资总和，平均工资，过滤掉平均工资低于2000的部门，按照平均工资升序排序
select deptno,sum(sal),avg(sal) a from emp
where sal between 1000 and 3000
group by deptno
having a&gt;=2000 order by a;
</li>
<li>
查询emp表中名字不是以s开头，每个职位的名字，人数，工资总和，最高工资，过滤掉平均工资是3000的职位，根据人数升序排序，如果一致根据工资总和降序排序
select job,count(*) c,sum(sal) s,max(sal) from emp where ename not like 's%'
group by job
having avg(sal)!=3000
order by c,s desc;
</li>
<li>
<p>查询emp表 每年入职的人数（提高题）</p>
<p>select extract(year from hiredate) year,count(*) from emp group by year;</p>
</li>
</ol>
<h3>子查询(嵌套查询)</h3>
<ol>
<li>
查询emp表中工资最高的员工信息
select max(sal) from emp;
select * from emp where sal=5000;
</li>
<li>
将以上两条合并成一条sql
select * from emp where sal=(select max(sal) from emp);
</li>
<li>
查询emp表中工资超过平均工资的所有员工信息
select * from emp where sal&gt;(select avg(sal) from emp);
</li>
<li>
查询工资高于20号部门平均工资的员工信息
select * from emp where sal&gt;(select avg(sal) from emp where deptno=20);
</li>
<li>
查询和Jones相同工作的其它员工信息
select job from emp where ename='jones';
select * from emp where job=(select job from emp where ename='jones') and ename!='jones';
</li>
<li>
<p>查询工资最低的员工的相同部门的员工信息
select min(sal) from emp;</p>
<p>select deptno from emp where sal=(select min(sal) from emp);</p>
<p>select * from emp where deptno=(select deptno from emp where sal=(select min(sal) from emp));</p>
</li>
<li>
<p>having 要和 group by 结合使用 </p>
</li>
<li>
<p>查询最后入职的员工信息 </p>
<p>select * from emp where hiredate=(select max(hiredate) from emp);</p>
</li>
<li>
<p>查询姓名为king的部门编号和部门名称（需要使用dept表）
select deptno from emp where ename='king';</p>
<p>select deptno,dname from dept where deptno=(select deptno from emp where ename='king');</p>
</li>
<li>查询有商品的分类id和分类名称（有商品 就是在商品表中出现的分类，需要使用t<em>item</em>category表）</li>
<li>
<p>先从商品表中得到所有的分类id </p>
<p>select distinct category<em>id from t</em>item;</p>
</li>
<li>
从分类表中查询id等于上面结果的分类信息
select id,name from t<em>item</em>category
where id in(select distinct category<em>id from t</em>item);
</li>
<li>
<p>查询有员工的部门信息</p>
<p>select distinct deptno from emp;</p>
<p>select * from dept where deptno in(select distinct deptno from emp);</p>
</li>
<li>扩展题（难度最高）：查询平均工资最高的部门信息</li>
<li>
得到最高的平均工资
select avg(sal) a from emp group by deptno order by a desc limit 0,1;
</li>
<li>
通过最高的平均工资 得到 部门的编号
select deptno from emp
group by deptno
having avg(sal)=(select avg(sal) a from emp group by deptno order by a desc limit 0,1);
</li>
<li>
通过部门编号得到部门信息
select * from dept where deptno in(select deptno from emp
group by deptno
having avg(sal)=(select avg(sal) a from emp group by deptno order by a desc limit 0,1));
</li>
</ol>
<h3>子查询总结</h3>
<ol>
<li>嵌套在SQL语句中查询语句称为子查询</li>
<li>子查询能嵌套n层 </li>
<li>子查询可写的位置：</li>
<li>可以写在 where/having的后面作为查询条件的值</li>
<li>可以写在 from后面 当一张新表 <strong>新表必须有别名</strong></li>
<li>
<p>可以写在创建表的时候</p>
<pre><code>create table t_emp_10 as (select * from emp where deptno=10);
</code></pre>

</li>
</ol>
<h3>关联查询</h3>
<ul>
<li>同时查询多张表的数据称为关联查询</li>
<li>
查询每一个员工的姓名和对应的部门名称
select e.ename,d.dname
from emp e,dept d
where e.deptno=d.deptno;
</li>
<li>
查询在纽约工作的所有员工的信息
select e.*
from emp e,dept d
where e.deptno=d.deptno and d.loc='new york';
</li>
</ul>
<h3>笛卡尔积</h3>
<ul>
<li>关联查询如果不写关联关系，则查询结果为两张表的乘积，这个乘积称为 笛卡尔积</li>
<li>笛卡尔积是一种错误的查询结果，工作中切记不要出现</li>
</ul>
<h3>等值连接和内连接</h3>
<ol>
<li>
等值连接：
select * from A,B 
where A.x=B.x and A.age=18
</li>
<li>
内连接 用的更多
select * from A join B
on A.x=B.x
where A.age=18;
</li>
<li>
查询每个员工的姓名和对应的部门名称
select e.ename,d.dname
from emp e join dept d
on e.deptno=d.deptno;
</li>
</ol>
<h3>外连接</h3>
<ul>
<li>
<p>左外连接： 以join 左边表为主表 左边表显示所有数据右边交集数据</p>
<p>select e.ename,d.dname
from emp e left join dept d
on e.deptno=d.deptno;</p>
</li>
<li>
<p>右外连接： 以join 右边表为主表 右边表显示所有数据左边交集数据</p>
<p>select e.ename,d.dname
from emp e right join dept d
on e.deptno=d.deptno;</p>
</li>
</ul>
<h3>关联查询总结：</h3>
<pre><code>    等值连接，内连接，外连接都是关联查询的查询方式使用哪一种取决于具体业务需求
</code></pre>

<ol>
<li>查两个表的交集数据 使用内连接(推荐)或等值连接</li>
<li>查一个表所有数据另外一个表交集数据使用外连接</li>
</ol>
<h3>内容回顾：</h3>
<ol>
<li>数学相关函数</li>
<li>floor</li>
<li>round(num,m) m代表小数位数</li>
<li>truncat(num,m）非四舍五入</li>
<li>rand()</li>
<li>group by  ....   having</li>
<li>子查询   写在 where/having 后面 写在 from后面当新表 必须写别名  写在 创建表的时候</li>
<li>关联查询  等值  内  外（左和右）</li>
</ol>
<h3>作业：</h3>
<ol>
<li>
<p>每个部门的人数,根据人数排序</p>
<ol>
<li>
<p>每个部门中，每个主管的手下人数</p>
</li>
<li>
<p>每种工作的平均工资</p>
</li>
<li>
<p>每年的入职人数 </p>
</li>
<li>
<p>少于等于3个人的部门信息</p>
</li>
<li>
<p>拿最低工资的员工信息</p>
</li>
<li>
<p>只有一个下属的主管信息</p>
</li>
<li>
<p>平均工资最高的部门编号</p>
</li>
<li>
<p>下属人数最多的人，查询其个人信息</p>
</li>
<li>
<p>拿最低工资的人的信息</p>
</li>
<li>
<p>最后入职的员工信息</p>
</li>
<li>
<p>工资多于平均工资的员工信息</p>
</li>
<li>
<p>查询员工信息，部门名称</p>
</li>
<li>
<p>员工信息，部门名称，所在城市</p>
</li>
<li>
<p>DALLAS 市所有的员工信息</p>
</li>
<li>
<p>按城市分组，计算每个城市的员工数量</p>
</li>
<li>
<p>查询员工信息和他的主管姓名</p>
</li>
<li>
<p>员工信息，员工主管名字，部门名</p>
</li>
<li>
<p>员工和他所在部门名</p>
</li>
<li>
<p>案例：查询emp表中所有员工的姓名以及该员工上级领导的编号，姓名，职位，工资</p>
</li>
<li>
<p>案例：查询emp表中名字中没有字母'K'的所有员工的编号，姓名，职位以及所在部门的编号，名称，地址</p>
</li>
<li>
<p>案例：查询dept表中所有的部门的所有的信息，以及与之关联的emp表中员工的编号，姓名，职位，工资</p>
</li>
</ol>
</li>
</ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
